// The grammar uses the regex-flavor qualifiers, meaning:
//  - ?: optional
//  - *: repeat 0 or more times
//  - +: repeat 1 or more times
//
// Lowercase names are rule names, uppercase names are token types.
// When more readable, the string value is used instead of the token type.
//
// To make some constructs more compact, parameterized grammar rules are also used,
// which are defined as:
// foo(BAR): '(' BAR ')' ;
// For example, foo(expr) would mean the sequence '(' expr ')'.

module_declaration   : declaration* End
                     ;

declaration          : function_declaration
                     ;

function_declaration : 'func' Identifier '(' parameter_list ')' type_specifier? function_body
                     ;

parameter_list       : comma_sep(parameter)
                     ;

parameter            : Identifier type_specifier
                     ;

function_body        : block_expression
                     | value_specifier ';'
                     ;

type_specifier       : ':' type
                     ;

value_specifier      : '=' expression
                     ;

type                 : Identifier
                     ;

expression           : block(expression)
                     | if(expression)
                     | while(expression)
                     | PrefixUnaryOp expression
                     | expression BinaryOp expression
                     | expression '(' argument_list ')'
                     | expression '[' argument_list ']'
                     | '(' expression ')'
                     | Identifier
                     ;

statement            : block(statement)
                     | if(statement)
                     | while(statement)
                     | var_statement
                     | expression ';'
                     ;

argument_list        : comma_sep(expression)
                     ;

var_statement        : 'var' Identifier type_specifier? value_specifier? ';'
                     | 'val' Identifier type_specifier? value_specifier ';'
                     ;

block(E)             : '{' statement* E? '}'
                     ;

if(E)                : 'if' expression 'then' E ('else' E)?
                     ;

while(E)             : 'while' expression 'do' E
                     ;

comma_sep(E)         : (E (',' E)* ','?)?
                     ;
